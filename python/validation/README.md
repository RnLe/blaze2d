# Module-Level Validation Harness

This directory hosts focused checks for individual modules described in `../../FULL_PIPELINE.md`. The goal is to exercise each checklist item in isolation (e.g., lattice construction, geometry voxelization, operator application) without running the entire solver pipeline.

## Approach

* All data for these checks is generated by the dedicated Rust CLI `mpb2d-validation` (see `crates/validation`). The CLI shares code with `mpb2d-core`, so it can produce canonical values quickly and deterministically. Each subcommand emits machine-readable JSON, exits non-zero when invariants fail, and can optionally persist artifacts.
* The local `Makefile` exposes one target per module/component name, matching the structure in `FULL_PIPELINE.md`. Running a target invokes the relevant `mpb2d-validation` command and stores artifacts under `python/validation/artifacts/<module>/`, keeping everything scoped to this folder. To keep things maintainable, the top-level file now just wires shared variables plus `all/clean` while each validation area lives in `mk/*.mk` include files.
* Downstream plotting or richer statistical analysis (Python scripts, notebooks, etc.) should read from these `artifacts/` subfolders or sibling notebooks in this directory; end-to-end pipeline regressions still live elsewhere.

## Current coverage

* `make lattice-data-square` / `make lattice-data-triangular` generate validation bundles for the "Checklist — Lattice data" section, covering real/reciprocal bases, dot-product orthogonality checks, and classification sanity checks. Artifacts land in `python/validation/artifacts/lattice_data/` and are ready for notebooks/plots.
* `make geometry-data` fans out into six dielectric grids (square + triangular lattices at resolutions 24, 48, and 128) with unique background/rod material combinations spanning ε=1→16 while keeping at least a 1.0 contrast gap. The resulting JSON artifacts in `python/validation/artifacts/geometry_data/` capture raw ε fields, fill-fraction deltas, and descriptive statistics for the "Checklist — Geometry & materials" items.
* `make kspace-data` now covers the "Checklist — k-space sampling" section. It emits (i) high-symmetry Γ→X→M→Γ paths for square lattices, (ii) Γ→M→K→Γ paths for triangular lattices, (iii) a custom reduced-coordinate mesh, and (iv) a bespoke k-path that skips the presets. Artifacts live in `python/validation/artifacts/kspace_data/` and contain reciprocal bases, per-point metadata, and validation summaries (wrapping, adjacency, uniqueness checks).
* `make precompute-data` drives the Module C checklist. It runs `mpb2d-validation -- precompute-data …` across the 12 canonical (lattice, resolution, mesh_size) tuples, emits JSON summaries, ε(G) Fourier CSVs, and FFT workspace CSVs under `python/validation/artifacts/precompute_data/`, and feeds two notebooks: `precompute_moduleC.ipynb` (orchestrates runs, validates artifacts, persists metadata) and `precompute_visualization.ipynb` (Matplotlib-only plots that keep Re ε(G)=0 white and show |k+G|² / clamp masks).

### Geometry data provenance

The `geometry_validation.ipynb` notebook only touches epsilon arrays that originate from the exact Rust code path used by the production pipeline:

1. Notebook Cell 2 loads `geometry_*.json` via `load_reports()` (see `python/validation/geometry_validation.ipynb`).
2. Those JSON files are generated by `make geometry-data`, which shells out to `cargo run -p mpb2d-validation -- geometry-data …` (see `python/validation/Makefile`).
3. The `geometry-data` subcommand lives in `crates/validation/src/main.rs` and delegates to `validation_geometry::run()`.
4. `validation_geometry::run()` (in `crates/validation/src/validation_geometry.rs`) builds a `Geometry2D` from `mpb2d_core::geometry` and samples it via `Geometry2D::relative_permittivity_at_fractional`.
5. The same `Geometry2D` type feeds the solver pipeline: `mpb2d-cli` parses a `JobConfig` ( `crates/core/src/io.rs` ), the bandstructure driver calls `Dielectric2D::from_geometry()` (`crates/core/src/dielectric.rs`), which in turn evaluates `Geometry2D::relative_permittivity_at_cartesian/fractional`.

Because both the validation CLI and the solver share the identical `mpb2d_core::geometry` code, the epsilon grids plotted in the notebook are guaranteed to match the dielectric samples emitted during a real pipeline run (modulo any optional smoothing choices you make when invoking the solver).

### Numerics & smoothing coverage

* `make smoothing-data` mirrors the six canonical geometry tuples (same lattice/resolution/ε combos) and sweeps every one of them across `mesh_size ∈ {1,4,12}`. Artifacts land in `python/validation/artifacts/smoothing_data/`.
* The `smoothing-data` target uses `mpb2d-validation -- smoothing-data …`, which internally constructs `Dielectric2D::from_geometry()` on a `Grid2D::new(N,N,1,1)` so the reported ε fields are exactly what the solver would feed to FFT machinery.
* `geometry_validation.ipynb` Cells 5–6 load these JSON payloads, build a stats table (min/max/mean, delta norms), and visualize every lattice/resolution tuple across the mesh-size sweep by comparing `mesh_size=1` (raw) against smoothed outputs. This confirms that mesh_size, resolution, and material parameters surface consistently from the Makefile through the CLI into notebook diagnostics.

### K-space sampling coverage

`kspace_validation.ipynb` ingests the JSON artifacts from `make kspace-data`, plots the 3x3 reciprocal lattice grid for each lattice, and overlays:

1. The square Γ–X–M–Γ symmetry path.
2. The triangular Γ–M–K–Γ symmetry path.
3. A custom 2D reduced-coordinate mesh derived from the triangular reciprocal basis.
4. A hand-crafted custom path that highlights disabling the presets.

Each plot includes cumulative path lengths, segment names, and confirms that the sampled k-points remain inside the intended Brillouin-zone slices, satisfying the plotting/logging portion of the checklist.

### Module C (Precomputation) coverage

`make precompute-data` mirrors the CLI invocations described above, and `precompute_moduleC.ipynb` handles Sections 1–6 of its flow (parameter grid → cargo runs → JSON/CSV validation → metadata persistence). Section 7, together with the standalone `precompute_visualization.ipynb`, renders ε(G) spectra and FFT diagnostics for every configuration. These notebooks verify TE/TM effective permittivities (now aligned with the arithmetic/harmonic convention in `FULL_PIPELINE.md`), confirm clamp masks stay localized, and ensure the smoothed ε(G) behaves across lattices/resolutions. All artifacts remain under `python/validation/artifacts/precompute_data/`, so rerunning either notebook never touches the Rust build.

### Reciprocal indexing coverage

`make reciprocal-data` drives `mpb2d-validation -- reciprocal-data …` for both square and triangular lattices at (resolution=32, mesh_size=4) with three samples per symmetry-leg (Γ→X→M→Γ or Γ→M→K→Γ). Each run emits a JSON payload under `python/validation/artifacts/reciprocal_data/` that captures the complete `(ix,iy)→(m_x,m_y)` map, raw k+G tables, histogram summaries, and aliasing checks for all seven high-symmetry k-points. Downstream notebooks use these artifacts to visualize |k+G|² histograms, confirm centered-index remapping, and document any near-zero clamps before progressing to operator assembly.

Future commits should keep adding make targets + CLI subcommands that mirror the remaining checklists, keeping this directory as the single place to run module-scoped validations.
